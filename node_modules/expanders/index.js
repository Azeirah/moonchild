'use strict';

var Symbol = require('es6-symbol');

var slice = Array.prototype.slice;
var hasOwnProp = Object.prototype.hasOwnProperty;

// Helpers
// -------

// Makes a copy of `obj`, omitting properties given by `keys` (an Array).
function omit(obj, keys) {
  var copy = Object.create(null);
  for (var key in obj) {
    if (keys.indexOf(key) == -1)
      copy[key] = obj[key];
  }
  return copy;
}

// Expander
// --------

function Expander(symbols) {
  this._symbols = Object.seal(symbols);
}

Expander.withKeys = function() {
  var symbols = Object.create(null);
  for (var i = 0; i < arguments.length; ++i) {
    var name = arguments[i];
    var sym = Symbol(name);  // jshint ignore:line
    symbols[name] = sym;
  }
  return new Expander(symbols);
};

// Returns an Array of property names defined by this Expander.
// If `optionalObj` is specified, returns only the names of properties which
// exist in the given object. If `includeProto` is true, returns the names of
// properties which exist in the object or any of its prototypes.
Expander.prototype.keys = function(optionalObj, includeProto) {
  var keys = Object.keys(this._symbols);
  if (optionalObj) {
    var self = this;
    var predicate = includeProto ?
        function(k) { return self.has(optionalObj, k); } :
        function(k) { return self.hasOwn(optionalObj, k); };
    return keys.filter(predicate);
  }
  return keys;
};

// Sets an expander property of an object to the given value.
// Throws an exception if `name` is not defined in this Expander.
Expander.prototype.set = function(obj, name, value) {
  if (typeof name == 'string') {
    if (!(name in this._symbols))
      throw new ReferenceError(name + ' is not defined in expander');
    Object.defineProperty(obj, this._symbols[name], {
      value: value, configurable: true, enumberable: true, writable: true
    });
    return obj[this._symbols[name]];
  }
  // Support the shorthand for setting multiple properties.
  for (var k in name) {
    if (hasOwnProp.call(name, k))
      this.set(obj, k, name[k]);
  }
};

// Returns a new Expander that is a copy of this one, except the `name`
// property is renamed to `newName`. To rename multiple properties, it can be
// called with a single argument: an Object<String, String> which maps from
// old names to new names.
Expander.prototype.rename = function(name, newName) {
  var copy;
  if (name instanceof Object) {
    copy = omit(this._symbols, Object.keys(name));
    for (var k in name) {
      if (hasOwnProp.call(name, k))
        copy[name[k]] = this._symbols[k];
    }
  } else {
    copy = omit(this._symbols, [name]);
    copy[newName] = this._symbols[name];
  }
  return new Expander(copy);
};

// Returns a new Expander that is a copy of this one, except without the
// properties specified in the arguments list.
Expander.prototype.remove = function() {
  var symbols = omit(this._symbols, slice.call(arguments));
  return new Expander(symbols);
};

// Gets an object property, using the properties defined by this
// Expander (if applicable). Otherwise, acts like regular property access.
Expander.prototype.get = function(obj, propName) {
  var sym = this._symbols[propName];
  return sym ? obj[sym] : void 0;
};

// Returns true if this Expander has an applicable property for the given
// object and property name, searching the object and the prototype chain.
Expander.prototype.has = function(obj, propName) {
  // Strings don't support 'in' in JavaScript, and string instances can't be
  // expanded, so the only way to expand strings is via the prototype.
  if (typeof obj == 'string')
    return propName in String.prototype;
  return this._symbols[propName] in obj;
};

// Returns true if this Expander has an applicable property for the given
// object and property name, searcing only the object and NOT its prototype.
Expander.prototype.hasOwn = function(obj, propName) {
  return hasOwnProp.call(obj, this._symbols[propName]);
};

// Gets an object property using `get`, and calls it as a function, passing
// on all the arguments after `propName`.
Expander.prototype.send = function(obj, propName) {
  var fn = this.get(obj, propName);
  return fn.apply(obj, slice.call(arguments, 2));
};

// Creates a new Expander which is the union of all the arguments (which are
// Expanders). Throws a TypeError if any duplicate keys exist.
function compose() {
  var copy = Object.create(null);
  for (var i = 0; i < arguments.length; ++i) {
    var exp = arguments[i];
    for (var key in exp._symbols) {
      if (key in copy) {
        var msg = "Can't compose expanders with duplicate key " + key;
        throw new TypeError(msg);
      }
      copy[key] = exp._symbols[key];
    }
  }
  return new Expander(copy);
}

// Exports
// -------

module.exports = {
  createExpander: Expander.withKeys,
  compose: compose
};
